[General]
nbSubsys=6
subsysType0=MultiNetQuicDevice
subsysName0=MultiNetQuicManager
subsysId0=2
subsysAck0=2
subsysType1=UDP
subsysName1=Switches
subsysId1=3
subsysAck1=0
currentId=8
subsysType2=TCP
subsysName2=IMACRT1
subsysId2=4
subsysAck2=0
subsysType3=TCP
subsysName3=IMACRT2
subsysId3=5
subsysAck3=0
subsysType4=TCP
subsysName4=IMACRT3
subsysId4=6
subsysAck4=0
subsysType5=TCP
subsysName5=IMACRT4
subsysId5=7
subsysAck5=0

[commands]
MULTINETQUICMANAGER\commands="customCommand\t,40 \t,10\t,4\t,asicNum,24,id,8,cn,8,corps,bytearray\t,{1}AA55 {2} {3} {4} FADA\t#commande customisable\n\n#commandes ASIC \n\nsetAsicParam\t\t,50\t,11\t,3,asicNum,24,address,4,value,6\t,{1}AA55 00 00 0{3}{2}FADA\t# configure l'asic (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetAsicApol\t\t,51\t,11\t,2,asicNum,24,value,6\t\t,{1}AA55 00 00 0{2}1FADA\t# polarisation des blocs analogiques (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetAsicSpol\t\t,52\t,11\t,2,asicNum,24,value,6\t\t,{1}AA55 00 00 0{2}4FADA \t# polarisation des squids (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetAsicVicm\t\t,53\t,11\t,2,asicNum,24,value,6\t\t,{1}AA55 00 00 0{2}2FADA\t# tension de mode commun Vicm (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetAsicVocm\t\t,54\t,11\t,2,asicNum,24,value,6\t\t,{1}AA55 00 00 0{2}3FADA\t# tension de mode commun Vocm (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetAsicSetColumn\t,55\t,11\t,2,asicNum,24,startStopCol,4\t\t,{1}AA55 00 00 00{2}5FADA\t# circuit d'adressage: position initiale et finale colonne (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetAsicSelStartRow\t,56\t,11\t,2,asicNum,24,value,5\t\t,{1}AA55 00 00 0{2}6FADA\t# circuit d'adressage: position initiale ligne (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetAsicSelLastRow\t,57\t,11\t,2,asicNum,24,value,5\t\t,{1}AA55 00 00 0{2}7FADA\t# circuit d'adressage: position finale ligne (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\n\n#setAsicCommand\t,58\t,11\t,2,asicNum,24,signalId,8\t\t,{1}AA55 10 00 00{2}FADA\t# Envoi une pulse suivant signalId: 0= RAZb 1 INIb (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetAsicRazb\t\t,59\t,11\t,1,asicNum,24\t\t\t,{1}AA55 10 00 0000 FADA\t# Envoi une pulse RAZb (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetAsicInib\t\t,60\t,11\t,1,asicNum,24\t\t\t,{1}AA55 10 00 0001 FADA\t# Envoi une pulse INIb (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\n\n#commandes carte FPGA\nsetDiffDAC\t\t,0\t,11\t,2,asicNum,24,diffDACValue,16\t\t,{1}AA55 01 00{2}FADA\t# configure le DAC différenciel avec la valeur diffDACValue pour l'asic asicNum (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetFeedbackTable\t,1\t,265\t,2,asicNum,24,feedbackTable,128*16\t,{1}AA55 02 00{2}FADA\t# configure la table de feedback (128*16bits) pour l'asic asicNum (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetOffsetTable\t\t,20\t,265\t,2,asicNum,24,offsetTable,128*16\t,{1}AA55 22 00{2}FADA\t# configure la table d'offsets (128*16bits) pour l'asic asicNum (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\n\nsetMask\t\t,3\t,135\t,2,asicNum,24,mask,125*8\t\t,{1}AA55 03 00{2}00FADA\t# configure le masque avec la table mask(128*8bits) pour l'asic asicNum (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetSlowDAC\t\t,4\t,11\t,2,asicNum,24,slowDACValue,16\t\t,{1}AA55 04 00{2}FADA\t# configure le DAC lent avec la valeur DACValue pour l'asic asicNum (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetNSample\t\t,5\t,11\t,1,Nsample,16\t\t\t,0000 FF AA55 05 00{1}FADA\t# configure le Nsample pour tous les ASICs\n\nstartAcq\t\t,6\t,9\t,1,asicNum,24\t\t\t,{1}AA55 06 00FADA\t# demarrage de l'acquisition de la carte NetQuic (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nstopAcq\t\t,7\t,9\t,1,asicNum,24\t\t\t,{1}AA55 07 00FADA\t# arret de l'acquisition de la carte NetQuic (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\n\nsetAcqScienceMode\t,9\t,11\t,2,asicNum,24,testMode,16\t\t\t,{1}AA55 09 00{2}FADA \t# configuration de la carte NetQuic en mode science:0, ou test pattern: 1 (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\n\nresetNetquic\t\t,10\t,9\t,1,asicNum,24\t\t\t,{1}AA55 0A 00FADA\t# reset de la carte NetQuic (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\n\nsetCycleRawMode\t,11\t,11\t,2,asicNum,24,undersampling,16\t\t,{1}AA55 0B 00{2}FADA\t# bascule en mode raw signal cycle (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\n\nsetAsicConf\t\t,13\t,11\t,3,asicNum,24,signalId,8,state,8\t\t,{1}AA55 0D 00{2}{3} FADA\t# configure un signal a 1 ou 0\n\ngetStatus\t\t,14\t,9\t,1,asicNum,24\t\t\t,{1}AA55 0E 00FADA\t# demande le paquet status de la carte NetQuic (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\n\nsetFreqAcqPixel\t\t,15\t,11\t,2,asicNum,24,pixelAcqFreq,8\t\t,{1}AA55 0F 0000{2}FADA\t# change la frequence de lecture des pixels 0-200=> 0=>2kHz (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetFreqSerialLink\t,16\t,11\t,2,asicNum,24,serialFreq,8\t\t,{1}AA55 0F 0001{2}FADA\t# change la frequence du lien serie pour les commandes ASIC 0-200=> 0=>2kHz (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetFrequency\t\t,17\t,11\t,3,asicNum,24,frequencyId,8,frequency,8\t,{1}AA55 0F 00{2}{3}FADA\t# change la frequence en fonction de frequencyId (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\n\nsetCalibPolar\t\t,18\t,15\t,6,asicNum,24,mode,4,shape,4,frequency,8,amplitude,16,offset,16\t\t,{1}AA55 11 00{2}{3}{4}{5}{6}FADA\t# Specifie le signal de calib a injecter sur les TES mode:0 ou SQUID mode:1,  envoi du signal, shape: 0 sinus, 1 triangle, 2 continu  (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\n\nconfigurePID\t\t,21\t,15\t,4,asicNum,24,P,16,I,16,D,16\t\t,{1}AA55 13 00{2}{3}{4}FADA\t# configure les parametres de la regul (si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nactivatePID\t\t,22\t,11\t,2,asicNum,24,onOff,16\t\t,{1}AA55 14 00{2}FADA\t#active la regulation onOff = 1, desactive la regulation onOff = 0(si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\n\n\n"
SWITCHES\commands="SwitchesMsg\t\t,0,1,1,txtMsg,string,{1} # send the txtMessage to switches, notice if the \\r character is missed at the end of message, it will be automatically added \n#SwitchesConfigureOneRegister\t,1,0,2,registerAddress,16,value,16 #build and send the command to configure one register\n#SwitchesReadOneRegister\t,1,0,1,registerAddress,16\n#SwitchesReadRegisters\t,1,0,2,registerAddress,16,nbRegisters,8"
dispatcher\commands="\nresetVOffset\t,1\t,3\t,1,asicNum,24\t\t\t,{1}\t#reset des valeurs VOffset (mise a 0) de l'asic specifie(si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetVOffset\t,2\t,8\t,3,asicNum,24,pixelNum,8,voffset,float\t,{1}{2}{3}\t#configure la valeur VOffset pour le pixel (ou tous les pixels si pixelNum = 0xFF) de l'asic specifie(si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetVOffsets\t,3\t,515\t,2,asicNum,24,voffset,128*float\t\t,{1}{2}\t#configure la valeur VOffset pour tous les pixels de l'asic specifie(si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\n\nresetVout2IinCoeffs,4\t,3\t,1,asicNum,24\t\t\t,{1}\t#reset des valeurs Vout2Iin (mise a 1) de l'asic specifie(si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetVout2IinCoeffs,5\t,11\t,3,asicNum,24,MinMfb,float,Rfb,float\t,{1}{2}{3}\t#configure la valeur Vout2Iin =  Min/Mfb* Rfb pour l'asic specifie(si asicNum = 0xFF, la commande est envoyée a tous les ASIC, si asic num < 16, la commande est envoyée a l'ASIC asicNum, pour envoyer à une liste d'ASICs utiliser les bits 8 à 23 pour specifier la liste, ex asicNum = 0x00FF00 configurera les asic 0 à 7)\nsetVout2IinsCoeffs,6\t,128\t,2,MinMfb,16*float, Rfb,16*float\t,{1}{2}\t#configure les valeurs out2Iin =  Min/Mfb* Rfb de tous les asics \n\nsetScientificDataTfUsed,7\t,1\t,1,tfused,8\t\t\t,{1}\t#applique la fonction de transfert : 0 => signal brut, 1 => Vout, 2 => Iin\n\nstartBackup\t\t,8\t,3,2,sessionName,string_0,comment,string_0,01{1}{2}\t#start backup\nstopBackup\t\t,9\t,0\t\t\t\t#stop backup\n\n\n\n\n\n"
trash\commands="########################################\n########################################\n# commandes venant de TEST\n########################################\n########################################\n#exemples\nSet_40Hz_BOLC2       ,1, 10 , 0, 005507000000000000AA\nConf_UGTI_Temp2    ,2, 4 , 4,carteNum,2,channel,string,gain,4,courant,12, 0{1}{2}{3}{4}########################################\n########################################\n# commandes venant de TEST2\n########################################\n########################################\nfullCustomCommand,2,10,5,synchropWord,16,size,32,commandID,8,parameters,bytearray,checksum,16,{1}{2}{3}{4}{5} \t\t# trame à envoyer directement au sous systeme,utile pour vérifier la robustesse du sous système aux erreurs de protocole (bad synchroword, bad size, bad cheksum...)\ncustomCommand\t,1 \t,2\t,2\t,commandID,8,parameters,bytearray\t,{1}{2}\t#commande customisable pour le sous système incluant l'ID et le corp, le header et le checksum sera mis a jour automatiquement\n\n\nNop\t\t,0xA0,0\t\t\t #\"No Operation\". Test the communication between the MU and the BU\nTestHighSpeedLink\t,0xA1,0\t\t\t #Generate a test pattern on the Highspeed link to test it\nGetVersions\t\t,0xA2,0\t\t\t #Send back the versions of  Boot loader, User Software, Firmware, Board ID ( EDU,EM,QM,FM,FM spare…) this code will be set by pullup/pulldown resistors on the processor boards.\nGetBootReport\t\t,0xA3,0\t\t\t #Send back the boot report of the uController: RAM status,User software checksum, …\nGetHousekeepings\t,0xA4, 4,1, HKMask,32,{1}\t\t#Returns the selected HK. (Bit mask which allows the user to retrieve only the Hk(s) he is interrested in: 0 is no HK, 1 is HK 0, 2 is HK 1, 3 is HK 0 & 1 and so on)A\nGetLaserData\t\t,0xA5,0\t\t\t#Returns the laser data: Pumping current,Stack voltage, Optical power for each laser shot.\n\nsetSecondaryDCDCOnOff\t,0xB0,1,1,bitmask,1,0{1}\t\t#Set the secondaries voltages On/Off (bitmask = 0 => OFF, bitmask = 1 => ON)\nsetLaserConvertersOnOff\t,0xB1,1,1,bitmask,1,0{1}\t\t#Set the laser converters On/Off (bitmask = 0 => OFF, bitmask = 1 => ON)\nsetRMIOnOff\t\t,0xB2,1,1,bitmask,1,0{1}\t\t#Set the RMI On/Off (bitmask = 0 => OFF, bitmask = 1 => ON)\nsetThermalControlOnOff\t,0xB3,1,1,bitmask,3,0{1}\t\t#Set the thermal control On or Off for the CWL, Laser or IR. 'This is a 3 bits bitmask. The LSB is the CWL heater, the 2nd bit is the laser heater and the MSB is the IR TEC with 0=OFF, 1=ON\nsetCWLOnOff\t\t,0xB4,1,1,bitmask,3,0{1}\t\t#Set the CWL On or Off with or without modulation. Bit mask: '0' is off, '2' is on without modulation, '5' is on with modulation, other values are invalid and must be treted as Off\nsetMotorOnOff\t\t,0xB5,1,1,bitmask,1,0{1}\t\t#Enable or disable the stepper motor driver.(bitmask = 0 => OFF, bitmask = 1 => ON)\nsetIRSpectrometerOnOff\t,0xB6,1,1,bitmask,1,0{1}\t\t#Set the IR spectrometer ON or OFF.(bitmask = 0 => OFF, bitmask = 1 => ON)\nsetSunsafeOnOff\t,0xB7,1,1,bitmask,1,0{1}\t\t#Set the instrument in sunsafe mode.(bitmask = 0 => OFF, bitmask = 1 => ON)\n\nconfigureSerialLink\t,0xC0,1,1,baudrate,8,{1}\t\t#Set the parameters of the serial link between the MU and the BU.0 = 9600 bauds, 1 = 19200 bauds, 2 = 38400 bauds, 3 = 115200 bauds\nconfigureLaser\t\t,0xC1,7,6,pumpingCurrent,8,pumpingDuration,8,pockelsDelay,8,shotFrequency,8,numberOfShots,16,laserSelection,1,{1}{2}{3}{4}{5}0{6} # Configure the laser for X shots @ Y Hertz @Z Joules for the chosen line (RAMAN or LIBS)\nconfigureAutofocusSignals\t,0xC2,2,2,gain,4,demodulationSignalPhase,8,0{1}{2} #Configure the autofocus photodiode readout signal. with gain : 0 = gain of 2, 1 = gain of 8, 2 = gain of 32, 3 = gain of 128. phase can be set by steps of 2 degrees i.e 0 = 0 degree 179 = 358 degree\nconfigureStepperMotor\t,0xC3,2,2,currentLevel,8,motorSpeed, 8,{1}{2}\t#Configure the stepper motor current & speed. current : 0 = 100% of the max current 15 = 0% of the max current See the L6258EX datasheet for the truth table since steps are not linear. Max current will be set to 0,78 A\nconfigureThermalControl\t,0xC4,0,0\t\t\t#TBD\nconfigureIR\t\t,0xC5,0,0\t\t\t#TBD\nconfigureAutoExposure\t,0xC6,0,0\t\t\t#TBD\n\nstepperMotorMove\t,0xD0,7,5,displacementsNumber,16,stepsPerDisplacement,16,direction,1,bypassMode,1,samplingMode,1,{1}{2}0{3}0{4}0{5} #Move the stepper motor in the chosen direction by doing M displacements of N steps with/without sampling the autofocus signal.\ntakeIRSpectrum\t\t,0xD1,0,0\t\t\t#Take a passive infrared spectrum\ntakeRMIImage\t\t,0xD2,3,2,autoexposureMode,1,duration,16,0{1}{2} #TBD Take an RMI Image and send it to the BU\ndoAutofocus\t\t,0xD3,0,0\t\t\t#TBD\n\nabortDisplacement\t,0xE0,0,0\t\t\t#Interrupt the motor and set this system off in a safe way TBD.\nabortMU\t\t,0xE1,0,0\t\t\t#Interrupt SuperCam MU operations and set it Off in a safe way TBD."
IMACRT1\commands="toIMARCTR1\t\t,0,1,1,txtMsg,string,{1} # send the txtMessage to IMACTR, notice if the \\n character is missed at the end of message, it will be automatically added \n\n"
IMACRT2\commands="toIMARCTR2\t\t,0,1,1,txtMsg,string,{1} # send the txtMessage to IMACTR, notice if the \\n character is missed at the end of message, it will be automatically added \n"
IMACRT3\commands="toIMARCTR3\t\t,0,1,1,txtMsg,string,{1} # send the txtMessage to IMACTR, notice if the \\n character is missed at the end of message, it will be automatically added \n"
IMACRT4\commands="toIMARCTR4\t\t,0,1,1,txtMsg,string,{1} # send the txtMessage to IMACTR, notice if the \\n character is missed at the end of message, it will be automatically added \n"

[telemetries]
QUBIC_HK\fromSubsystem=MULTINETQUICMANAGER
QUBIC_SUM\fromSubsystem=MULTINETQUICMANAGER
QUBIC_RAW\fromSubsystem=MULTINETQUICMANAGER
SWITCHES\fromSubsystem=SWITCHES
IMACRT1\fromSubsystem=IMACRT1
IMACRT2\fromSubsystem=IMACRT2
IMACRT3\fromSubsystem=IMACRT3
IMACRT4\fromSubsystem=IMACRT4
